import torch
import torch.nn.functional as F
def multilabel_categorical_crossentropy(y_true, y_pred):
    y_pred = (1 - 2 * y_true) * y_pred
    y_pred_neg = y_pred - y_true * 1e12
    y_pred_pos = y_pred - (1 - y_true) * 1e12
    zeros = torch.zeros_like(y_pred[..., :1])
    y_pred_neg = torch.cat([y_pred_neg, zeros], dim=-1)
    y_pred_pos = torch.cat([y_pred_pos, zeros], dim=-1)
    neg_loss = torch.logsumexp(y_pred_neg, dim=-1)
    pos_loss = torch.logsumexp(y_pred_pos, dim=-1)
    return neg_loss + pos_loss


def global_pointer_crossentropy(y_true, y_pred,alpha=4):
    """给GlobalPointer设计的交叉熵
    """
    bh = y_pred.shape[0] * y_pred.shape[1]
    y_pred = torch.reshape(y_pred, (bh, -1))
    y_true = torch.reshape(y_true, (bh, -1))
    # return  0.5 * (torch.mean(multilabel_categorical_crossentropy(y_true_q, y_pred_q)) + torch.mean(multilabel_categorical_crossentropy(y_true_p, y_pred_p))) + 4 * kl_loss
    return torch.mean(multilabel_categorical_crossentropy(y_true, y_pred))